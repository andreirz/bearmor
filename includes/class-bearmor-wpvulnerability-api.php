<?php
/**
 * WPVulnerability API Class
 * Handles communication with wpvulnerability.net API
 *
 * @package Bearmor_Security
 */

class Bearmor_WPVulnerability_API {

	const API_BASE = 'https://www.wpvulnerability.net';
	const CACHE_DURATION = DAY_IN_SECONDS; // 24 hours

	/**
	 * Check plugin for vulnerabilities
	 *
	 * @param string $slug Plugin slug
	 * @param string $version Plugin version
	 * @param bool $force_refresh Skip cache
	 * @return array|WP_Error
	 */
	public static function check_plugin( $slug, $version, $force_refresh = false ) {
		// Check cache first (unless forced)
		$cache_key = 'bearmor_vuln_plugin_' . md5( $slug . $version );
		
		if ( ! $force_refresh ) {
			$cached = get_transient( $cache_key );
			
			if ( false !== $cached ) {
				error_log( 'BEARMOR API: Cache HIT for ' . $slug );
				return $cached;
			}
		}
		
		error_log( 'BEARMOR API: Cache MISS for ' . $slug . ' - will call API' );
		
		// Make API request
		$url = self::API_BASE . '/plugin/' . urlencode( $slug ) . '/';
		error_log( 'BEARMOR API: Calling ' . $url );
		
		$response = wp_remote_get( $url, array(
			'timeout' => 10,
			'headers' => array(
				'Accept' => 'application/json',
			),
		) );
		
		if ( is_wp_error( $response ) ) {
			error_log( 'BEARMOR API: WP Error - ' . $response->get_error_message() );
			return $response;
		}
		
		$body = wp_remote_retrieve_body( $response );
		error_log( 'BEARMOR API: Response - ' . substr( $body, 0, 200 ) );
		$data = json_decode( $body, true );
		
		if ( json_last_error() !== JSON_ERROR_NONE ) {
			return new WP_Error( 'json_error', 'Failed to parse API response' );
		}
		
		// Check if error
		if ( isset( $data['error'] ) && $data['error'] !== 0 ) {
			// No vulnerabilities found
			$result = array( 'vulnerabilities' => array() );
			set_transient( $cache_key, $result, self::CACHE_DURATION );
			return $result;
		}
		
		// Parse vulnerabilities
		$vulnerabilities = array();
		if ( isset( $data['data']['vulnerability'] ) && is_array( $data['data']['vulnerability'] ) ) {
			foreach ( $data['data']['vulnerability'] as $vuln ) {
				if ( self::is_version_affected( $version, $vuln ) ) {
					$vulnerabilities[] = self::parse_vulnerability( $vuln );
				}
			}
		}
		
		$result = array( 'vulnerabilities' => $vulnerabilities );
		
		// Cache result
		set_transient( $cache_key, $result, self::CACHE_DURATION );
		
		return $result;
	}

	/**
	 * Check theme for vulnerabilities
	 *
	 * @param string $slug Theme slug
	 * @param string $version Theme version
	 * @param bool $force_refresh Skip cache
	 * @return array|WP_Error
	 */
	public static function check_theme( $slug, $version, $force_refresh = false ) {
		// Check cache first (unless forced)
		$cache_key = 'bearmor_vuln_theme_' . md5( $slug . $version );
		
		if ( ! $force_refresh ) {
			$cached = get_transient( $cache_key );
			
			if ( false !== $cached ) {
				return $cached;
			}
		}
		
		// Make API request
		$url = self::API_BASE . '/theme/' . urlencode( $slug ) . '/';
		$response = wp_remote_get( $url, array(
			'timeout' => 10,
			'headers' => array(
				'Accept' => 'application/json',
			),
		) );
		
		if ( is_wp_error( $response ) ) {
			return $response;
		}
		
		$body = wp_remote_retrieve_body( $response );
		$data = json_decode( $body, true );
		
		if ( json_last_error() !== JSON_ERROR_NONE ) {
			return new WP_Error( 'json_error', 'Failed to parse API response' );
		}
		
		// Check if error
		if ( isset( $data['error'] ) && $data['error'] !== 0 ) {
			// No vulnerabilities found
			$result = array( 'vulnerabilities' => array() );
			set_transient( $cache_key, $result, self::CACHE_DURATION );
			return $result;
		}
		
		// Parse vulnerabilities
		$vulnerabilities = array();
		if ( isset( $data['data']['vulnerability'] ) && is_array( $data['data']['vulnerability'] ) ) {
			foreach ( $data['data']['vulnerability'] as $vuln ) {
				if ( self::is_version_affected( $version, $vuln ) ) {
					$vulnerabilities[] = self::parse_vulnerability( $vuln );
				}
			}
		}
		
		$result = array( 'vulnerabilities' => $vulnerabilities );
		
		// Cache result
		set_transient( $cache_key, $result, self::CACHE_DURATION );
		
		return $result;
	}

	/**
	 * Parse vulnerability data from API response
	 *
	 * @param array $vuln Raw vulnerability data
	 * @return array Parsed vulnerability
	 */
	private static function parse_vulnerability( $vuln ) {
		// Get severity from CVSS score
		$severity = 'medium';
		if ( isset( $vuln['impact']['cvss']['severity'] ) ) {
			$sev_code = strtolower( $vuln['impact']['cvss']['severity'] );
			$severity_map = array(
				'c' => 'critical',
				'h' => 'high',
				'm' => 'medium',
				'l' => 'low',
			);
			$severity = isset( $severity_map[ $sev_code ] ) ? $severity_map[ $sev_code ] : 'medium';
		}
		
		// Get fixed version
		$fixed_in = '';
		if ( isset( $vuln['operator']['max_version'] ) && $vuln['operator']['unfixed'] == 0 ) {
			$fixed_in = $vuln['operator']['max_version'];
		}
		
		// Get description and CVE references from sources
		$description = '';
		$cve_refs = array();
		if ( isset( $vuln['source'] ) && is_array( $vuln['source'] ) ) {
			foreach ( $vuln['source'] as $source ) {
				if ( ! empty( $source['description'] ) && empty( $description ) ) {
					$description = $source['description'];
				}
				if ( ! empty( $source['id'] ) ) {
					$cve_refs[] = $source['id'];
				}
			}
		}
		
		return array(
			'title'          => isset( $vuln['name'] ) ? $vuln['name'] : 'Unknown Vulnerability',
			'description'    => $description,
			'severity'       => $severity,
			'fixed_in'       => $fixed_in,
			'cve_references' => implode( ', ', $cve_refs ),
		);
	}

	/**
	 * Check if a version is affected by a vulnerability
	 *
	 * @param string $version Current version
	 * @param array $vuln Vulnerability data
	 * @return bool
	 */
	private static function is_version_affected( $version, $vuln ) {
		if ( ! isset( $vuln['operator'] ) ) {
			return false;
		}
		
		$op = $vuln['operator'];
		
		// Check if unfixed (always vulnerable)
		if ( isset( $op['unfixed'] ) && $op['unfixed'] == 1 ) {
			return true;
		}
		
		// Check max version with operator
		if ( isset( $op['max_version'] ) && ! empty( $op['max_version'] ) ) {
			$operator = isset( $op['max_operator'] ) ? $op['max_operator'] : 'le';
			
			// le = less than or equal, lt = less than
			if ( $operator === 'le' ) {
				return version_compare( $version, $op['max_version'], '<=' );
			} elseif ( $operator === 'lt' ) {
				return version_compare( $version, $op['max_version'], '<' );
			}
		}
		
		// Check min version with operator
		if ( isset( $op['min_version'] ) && ! empty( $op['min_version'] ) ) {
			$operator = isset( $op['min_operator'] ) ? $op['min_operator'] : 'ge';
			
			// ge = greater than or equal, gt = greater than
			if ( $operator === 'ge' ) {
				return version_compare( $version, $op['min_version'], '>=' );
			} elseif ( $operator === 'gt' ) {
				return version_compare( $version, $op['min_version'], '>' );
			}
		}
		
		return false;
	}

	/**
	 * Get severity color
	 *
	 * @param string $severity
	 * @return string
	 */
	public static function get_severity_color( $severity ) {
		$colors = array(
			'high'     => '#d63638',  // Red (was critical)
			'medium'   => '#f56e28',  // Orange (was high)
			'low'      => '#00a32a',  // Green
			'critical' => '#d63638',  // Legacy support
		);
		
		return isset( $colors[ $severity ] ) ? $colors[ $severity ] : '#666';
	}

	/**
	 * Get severity label
	 *
	 * @param string $severity
	 * @return string
	 */
	public static function get_severity_label( $severity ) {
		$labels = array(
			'critical' => 'ðŸ”´ Critical',
			'high'     => 'ðŸŸ  High',
			'medium'   => 'ðŸŸ¡ Medium',
			'low'      => 'ðŸŸ¢ Low',
		);
		
		return isset( $labels[ $severity ] ) ? $labels[ $severity ] : ucfirst( $severity );
	}
}
